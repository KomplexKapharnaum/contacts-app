<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>KXKM Mocap</title>
  
  <link rel="stylesheet" href="https://unpkg.com/handsfree@8.5.1/build/lib/assets/handsfree.css" />
  <script src="https://unpkg.com/handsfree@8.5.1/build/lib/handsfree.js"></script>

  <style>
    body {
      background: black;
      color: #f0f0f0;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
    }

    html, body {
      
      width: 100vw;
      height: 100vh;
      margin: 0;
      padding: 0;
      overflow: hidden;
      box-sizing: border-box;
    }
    #container {
      position: absolute;
      display: inline-block;
      top: 0px;
      left: 0px;
      max-width: 100vw;
      max-height: 100vh;
      overflow: hidden;
    }

    h3 {
      position: absolute;
      top: 1px;
      left: 550px;
      color: #f0f0f0;
      font-size: 24px;
      text-align: center;
    }

    #preview, #canvas {
      max-width: 100vw;
      max-height: 100vh;
      display: block;
      position: absolute;
      top: 0;
      left: 0;
    }

    #preview {
      z-index: 5;
      object-fit: cover;
      object-position: center;
      opacity: 0.3;
    }

    #canvas {
      z-index: 10;
      pointer-events: none;
      background: transparent;
    }

    #mini-canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 10;
      border: 1px solid yellow;
    }

    #camera-switch {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 20;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border: 2px solid #f0f0f0;
      border-radius: 8px;
      padding: 10px 15px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    #camera-switch:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: #00ffff;
    }

    #camera-switch:active {
      transform: scale(0.95);
    }

    #fullscreen-toggle {
      position: fixed;
      top: 70px; /* 20px (camera-switch top) + 40px (button height) + 10px spacing */
      right: 20px;
      z-index: 20;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border: 2px solid #f0f0f0;
      border-radius: 8px;
      padding: 10px 15px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    #fullscreen-toggle:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: #00ffff;
    }
    #fullscreen-toggle:active {
      transform: scale(0.95);
    }

    .handsfree-debug,
    .handsfree-pointer,
    .handsfree-cursor,
    .handsfree-gesture {
      display: none !important;
    }

  </style>

</head>
<body>
  <!-- <h3>Handsfree.js Pose, Hands & Face Demo</h3>toodego -->
    <div id="container">
    <video id="preview" autoplay playsinline></video>
    <canvas id="canvas"></canvas>
    <canvas id="mini-canvas" width="512px" height="512px"></canvas>
  </div>
  <button id="camera-switch">ðŸ“± Switch Camera</button>
  <button id="fullscreen-toggle">ðŸ–µ Fullscreen</button>
  <script>
    // Configuration
    const CONFIG = {
      FRAME_RATE_LIMIT: 30, // Target FPS for mini canvas
      MAX_WIDTH: window.innerWidth,      // Maximum preview width: viewport width
      MAX_HEIGHT: window.innerHeight,      // Maximum preview height: viewport height
      DEFAULT_MINI_WIDTH: 512
    };

    // Initialize Handsfree.js with optimized settings (using our video element)
    const handsfree = new Handsfree({
      showDebug: false,
      hands: {
        enabled: true,
        gesture: false,
        minDetectionConfidence: 0.7
      },
      pose: {
        enabled: true,
        smoothLandmarks: true,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
      },
      facemesh: true,
      setup: {
        video: {
          $el: document.getElementById('preview')
        }
      }
    });

    // DOM elements
    const preview = document.getElementById('preview');
    const mainCanvas = document.getElementById('canvas');
    const ctx = mainCanvas.getContext('2d');
    const miniCanvas = document.getElementById('mini-canvas');
    const miniCtx = miniCanvas.getContext('2d');

    // Canvas dimensions will be set based on video dimensions
    let canvasWidth = CONFIG.MAX_WIDTH;
    let canvasHeight = CONFIG.MAX_HEIGHT;

    // Camera switching variables
    let currentStream = null;
    // Determine initial facing mode from URL parameter 'cam'
    const camParam = new URLSearchParams(window.location.search).get('cam');
    const currentFacingMode = camParam === 'environment' ? 'environment' : 'user';
    // Stream switching will reload the page instead of dynamic update
    // let isInitialized = false;

    // URL parameters for mini canvas sizing
    const urlParams = new URLSearchParams(window.location.search);
    const hasCustomSize = urlParams.has('w') || urlParams.has('h');
    
    if (hasCustomSize) {
      const specifiedWidth = urlParams.has('w') ? parseInt(urlParams.get('w'), 10) : null;
      const specifiedHeight = urlParams.has('h') ? parseInt(urlParams.get('h'), 10) : null;
      
      if (specifiedWidth && specifiedHeight) {
        // Both w and h specified - use exact dimensions (may deform 1:2 ratio)
        miniCanvas.width = specifiedWidth;
        miniCanvas.height = specifiedHeight;
      } else if (specifiedWidth) {
        // Only width specified - calculate height for 1:2 ratio
        miniCanvas.width = specifiedWidth;
        miniCanvas.height = specifiedWidth * 2;
      } else if (specifiedHeight) {
        // Only height specified - calculate width for 1:2 ratio
        miniCanvas.height = specifiedHeight;
        miniCanvas.width = specifiedHeight / 2;
      }
    } else {
      // Default sizing
      miniCanvas.width = CONFIG.DEFAULT_MINI_WIDTH;
      miniCanvas.height = miniCanvas.width * 2;
    }

    // Show/hide elements based on configuration
    if (!hasCustomSize) {
      miniCanvas.style.display = 'none';
    } else {
      preview.style.display = 'none';
      mainCanvas.style.display = 'none';
      const h3 = document.querySelector('h3');
      if (h3) h3.style.display = 'none';
    }

    // Pre-calculate crop dimensions for main canvas
    let mainWidth, mainHeight, cropHeight, cropWidth, sx, sy;

    // Video crop dimensions (calculated once video loads)
    let videoCropData = null;

    // Frame rate limiting for mini canvas
    let lastMiniCanvasUpdate = 0;
    const miniCanvasInterval = 1000 / CONFIG.FRAME_RATE_LIMIT;

    // Initialize webcam first
    navigator.mediaDevices.getUserMedia({ video: { facingMode: currentFacingMode } }).then(stream => {
      currentStream = stream; // save stream for switching
      preview.srcObject = stream;
      // Detect if multiple cameras available to show switch button
      let showSwitch = false;
      const track = stream.getVideoTracks()[0];
      if (track.getCapabilities) {
        const caps = track.getCapabilities();
        if (caps.facingMode && caps.facingMode.length > 1) {
          showSwitch = true;
        }
      }
      if (!showSwitch && navigator.mediaDevices.enumerateDevices) {
        navigator.mediaDevices.enumerateDevices().then(devices => {
          const inputs = devices.filter(d => d.kind === 'videoinput');
          if (inputs.length > 1) showSwitch = true;
          switchButton.style.display = showSwitch ? 'block' : 'none';
        }).catch(err => console.error('Device enumeration error:', err));
      } else {
        switchButton.style.display = showSwitch ? 'block' : 'none';
      }
    });

    // Calculate dimensions and start Handsfree.js once video metadata is loaded
    preview.addEventListener('loadedmetadata', () => {
      
      const videoWidth = preview.videoWidth;
      const videoHeight = preview.videoHeight;
      
      // Calculate display dimensions that fit within max bounds while maintaining aspect ratio
      let displayWidth = videoWidth;
      let displayHeight = videoHeight;
      
      if (displayWidth > CONFIG.MAX_WIDTH) {
        displayWidth = CONFIG.MAX_WIDTH;
        displayHeight = (videoHeight * CONFIG.MAX_WIDTH) / videoWidth;
      }
      
      if (displayHeight > CONFIG.MAX_HEIGHT) {
        displayHeight = CONFIG.MAX_HEIGHT;
        displayWidth = (videoWidth * CONFIG.MAX_HEIGHT) / videoHeight;
      }
      
      // Set canvas dimensions to match display dimensions
      canvasWidth = displayWidth;
      canvasHeight = displayHeight;
      mainCanvas.width = canvasWidth;
      mainCanvas.height = canvasHeight;
      
      // Update preview and canvas size
      preview.style.width = `${displayWidth}px`;
      preview.style.height = `${displayHeight}px`;
      mainCanvas.style.width = `${displayWidth}px`;
      mainCanvas.style.height = `${displayHeight}px`;
      
      // Update container size
      const container = document.getElementById('container');
      container.style.width = `${displayWidth}px`;
      container.style.height = `${displayHeight}px`;
      
      // Pre-calculate crop dimensions for main canvas
      updateCropDimensions()

      // Calculate video crop dimensions for mini canvas
      let VcropHeight = videoHeight;
      let VcropWidth = VcropHeight / 2;
      if (VcropWidth > videoWidth) {
        VcropWidth = videoWidth;
        VcropHeight = VcropWidth * 2;
      }
      videoCropData = {
        width: VcropWidth,
        height: VcropHeight,
        x: (videoWidth - VcropWidth) / 2,
        y: (videoHeight - VcropHeight) / 2
      };

      // Apply mirroring transform
      const mirrorTransform = 'scaleX(-1)';
      preview.style.transform = mirrorTransform;
      mainCanvas.style.transform = mirrorTransform;
      miniCanvas.style.transform = mirrorTransform;

      // Start Handsfree.js after video is ready
      handsfree.start();

      if (!hasCustomSize && preview.videoWidth && preview.videoHeight) {
        resizeToFitViewport();
      }
    });

    function updateCropDimensions() {
      mainWidth = canvasWidth;
      mainHeight = canvasHeight;
      mainHeight = canvasHeight;
      mainHeight = canvasHeight;
      cropHeight = mainHeight;
      cropWidth = cropHeight / 2;
      if (cropWidth > mainWidth) {
        cropWidth = mainWidth;
        cropHeight = cropWidth * 2;
      }
      sx = (mainWidth - cropWidth) / 2;
      sy = (mainHeight - cropHeight) / 2;
    }

    window.addEventListener('resize', () => {
      if (!hasCustomSize && preview.videoWidth && preview.videoHeight) {
        resizeToFitViewport();
      }
    });

    // 
    // VIEWPORT
    //

    function resizeToFitViewport() {
      const videoWidth = preview.videoWidth;
      const videoHeight = preview.videoHeight;
      const aspectRatio = videoWidth / videoHeight;

      // Use clientWidth/clientHeight for more accurate viewport size
      let displayWidth = document.documentElement.clientWidth;
      let displayHeight = document.documentElement.clientHeight;

      if (displayWidth / displayHeight > aspectRatio) {
        displayHeight = document.documentElement.clientHeight;
        displayWidth = displayHeight * aspectRatio;
      } else {
        displayWidth = document.documentElement.clientWidth;
        displayHeight = displayWidth / aspectRatio;
      }

      canvasWidth = displayWidth;
      canvasHeight = displayHeight;
      mainCanvas.width = canvasWidth;
      mainCanvas.height = canvasHeight;
      preview.style.width = `${displayWidth}px`;
      preview.style.height = `${displayHeight}px`;
      mainCanvas.style.width = `${displayWidth}px`;
      mainCanvas.style.height = `${displayHeight}px`;

      const container = document.getElementById('container');
      container.style.width = `${displayWidth}px`;
      container.style.height = `${displayHeight}px`;
    }

    //
    // DRAW
    //

    // Define hand connections (MediaPipe Hands format)
    const HAND_CONNECTIONS = [
      [0,1],[1,2],[2,3],[3,4],[2,5], // Thumb
      [5,6],[6,7],[7,8],      // Index
      [5,9],[9,10],[10,11],[11,12], // Middle
      [9,13],[13,14],[14,15],[15,16], // Ring
      [13,17],[17,18],[18,19],[19,20], // Pinky
      [0,17] // Palm base to pinky base
    ];

    // Define pose connections (MediaPipe Pose format)
    const POSE_CONNECTIONS = [
      [11,12], // Shoulders
      [11,13],[13,15], // Left arm
      [12,14],[14,16], // Right arm
      [11,23],[12,24], // Shoulders to hips
      [23,24], // Hips
      [24,26],[26,28], // Right leg
      [23,25],[25,27], // Left leg
      [27,29], [29,31], [27,31], // Left foot
      [28,30],[30,32], [28,32] // Right foot
    ];

    // Optimized mini canvas drawing with frame rate limiting
    function drawMiniCanvas() {
      const now = Date.now();
      if (now - lastMiniCanvasUpdate < miniCanvasInterval) {
        return; // Skip this frame
      }
      lastMiniCanvasUpdate = now;

      if (!videoCropData) return; // Wait for video metadata

      miniCtx.clearRect(0, 0, miniCanvas.width, miniCanvas.height);

      // Draw video background
      miniCtx.globalAlpha = 0.3;
      miniCtx.drawImage(
        preview,
        videoCropData.x, videoCropData.y, videoCropData.width, videoCropData.height,
        0, 0, miniCanvas.width, miniCanvas.height
      );
      miniCtx.globalAlpha = 1.0;

      // Draw overlay from main canvas - always draw as 1:2 ratio, then compress to canvas size
      // This ensures we get the 1:2 image compressed to whatever dimensions are specified
      miniCtx.drawImage(
        mainCanvas,
        sx, sy, cropWidth, cropHeight, // source crop (1:2 ratio from main canvas)
        0, 0, miniCanvas.width, miniCanvas.height // destination: compress to canvas size
      );
    }

    // Optimized drawing loop
    handsfree.use('drawAll', ({facemesh, hands, pose}) => {
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);

      // Set common drawing properties
      ctx.lineWidth = 2;

      // Draw face mesh
      if (facemesh?.multiFaceLandmarks) {
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 1;
        facemesh.multiFaceLandmarks.forEach(landmarks => {
          landmarks.forEach(({x, y}) => {
            ctx.beginPath();
            ctx.arc(x * canvasWidth, y * canvasHeight, 1.5, 0, 2 * Math.PI);
            ctx.stroke();
          });
        });
      }

      // Draw hand landmarks
      if (hands?.multiHandLandmarks) {
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        hands.multiHandLandmarks.forEach(landmarks => {
          // Draw connections
          HAND_CONNECTIONS.forEach(([start, end]) => {
            const s = landmarks[start];
            const e = landmarks[end];
            ctx.beginPath();
            ctx.moveTo(s.x * canvasWidth, s.y * canvasHeight);
            ctx.lineTo(e.x * canvasWidth, e.y * canvasHeight);
            ctx.stroke();
          });
          // Draw points
          landmarks.forEach(({x, y}) => {
            ctx.beginPath();
            ctx.arc(x * canvasWidth, y * canvasHeight, 3, 0, 2 * Math.PI);
            ctx.stroke();
          });
        });
      }

      // Draw pose keypoints
      if (pose?.poseLandmarks) {
        ctx.strokeStyle = '#ff00ff';
        ctx.lineWidth = 2;
        
        // Draw connections
        POSE_CONNECTIONS.forEach(([start, end]) => {
          const s = pose.poseLandmarks[start];
          const e = pose.poseLandmarks[end];
          if (s && e) {
            ctx.beginPath();
            ctx.moveTo(s.x * canvasWidth, s.y * canvasHeight);
            ctx.lineTo(e.x * canvasWidth, e.y * canvasHeight);
            ctx.stroke();
          }
        });

        // Draw keypoints (excluding face and hand indices)
        const ignoredIndices = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 17, 18, 19, 20, 21, 22];
        pose.poseLandmarks.forEach(({x, y}, i) => {
          if (!ignoredIndices.includes(i)) {
            ctx.beginPath();
            ctx.arc(x * canvasWidth, y * canvasHeight, 4, 0, 2 * Math.PI);
            ctx.stroke();
          }
        });
      }

      // Update mini canvas with frame rate limiting
      if (hasCustomSize) drawMiniCanvas();
    });

    // Camera switch button logic
    const switchButton = document.getElementById('camera-switch');
    // Hide button by default until we detect multiple cameras
    switchButton.style.display = 'none';
    // Show button only if more than one video input device is available
    navigator.mediaDevices.enumerateDevices().then(devices => {
      const videoInputs = devices.filter(d => d.kind === 'videoinput');
      if (videoInputs.length > 1) switchButton.style.display = 'block';
    }).catch(err => console.error('Device enumeration error:', err));
    switchButton.addEventListener('click', () => {
      // Reload page with updated camera parameter, preserving other query params
      const params = new URLSearchParams(window.location.search);
      const next = params.get('cam') === 'environment' ? 'user' : 'environment';
      params.set('cam', next);
      window.location.search = params.toString();
    });

    // Fullscreen toggle button logic
    const fullscreenButton = document.getElementById('fullscreen-toggle');
    fullscreenButton.addEventListener('click', () => {
      // Use the Fullscreen API with vendor prefixes for compatibility
      const elem = document.documentElement;
      if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
        if (elem.requestFullscreen) {
          elem.requestFullscreen();
        } else if (elem.webkitRequestFullscreen) { // Safari
          elem.webkitRequestFullscreen();
        } else if (elem.msRequestFullscreen) { // IE11
          elem.msRequestFullscreen();
        }
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { // Safari
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { // IE11
          document.msExitFullscreen();
        }
      }
    });
  </script>
</body>
</html>